[["index.html", "Dashboarding s paketom Shiny Uvod Motivacija Struktura te knjige", " Dashboarding s paketom Shiny Jana Faganeli Pucer, Patrik Kojanec, Matej Piulin in Erik trumbelj 2022-01-31 Uvod Motivacija Neobdelani podatki so obiajno preve obseni, da bi iz njih lahko hitro razbrali vse informacije. Takne podatke zato obiajno povzamemo z opisnimi statistikami (povpreja, razponi) in jih prikaemo s pomojo grafov ali tabel. Takoj, ko elimo to storiti, pa se pojavi teava: kateri povzetek je najbolj primeren za nae podatke? Katere metrike so najbolj pomembne in razumljive za nae ciljne uporabnike? Kaj pa, e jih zanima deset ali ve metrik? Kako bi jih smiselno zdruili v eno samo poroilo? Veliko povzetkov bi podaljalo poroilo, vsi povzetki na enem samem grafu ali v eni sami tabeli, pa bi bili nepregledni. S statinimi povzetki torej teko pregledamo in na en mah zajamemo vse pomembne informacije. Kot reitev teh omejitev so se razvila orodja, ki slonijo na kontrolnih ploah (angl. dashboard, izraz, ki ga bomo uporabljali v tej delavnici). Ta orodja temeljijo na kompromisu med preglednostjo in fleksibilnostjo prikaza. Uporabniku prikaemo manje tevilo povzetkov, ki pa so interaktivni in uporabniku omogoajo, da si jih prilagodi. Dashboard-i so tematika te delavnice. Spoznali bomo paket Shiny R, ki nam omogoa, da s pomojo programskga jezika R ustvarimo dashboard-e v obliki interaktivnih spletnih aplikacij. Ob koncu delavnice bomo znali ustvariti svoj dashboard, kot je na primer ta. Struktura te knjige Vsako poglavje ima 3 sklope: Priprava. Ta sklop je namenjen temu, da se udeleenci pripravijo na predavanje. Ker bodo le-ta intenzivna in namenjena predstavitvi glavnih konceptov ter uporabi funkcij na praktinih primerih, je dobro, da poznamo osnovne klice uporabljenih funkcij. V pripravi si bomo na preprostih podatkih pogledali, kako izvajati osnovne klice funkcij v tidyverse. Za vsako pripravo je na voljo video. Priprava traja najve 30 minut. Jedro. V tem sklopu je zajeta vsebina posameznega predavanja in vasih dodatna snov, ki jo predelamo samostojno. Podrobneje opiemo posamezne koncepte in funkcije ter demonstriramo na praktinih primerih. Domaa naloga. Na koncu vsakega predavanja so vaje za utrjevanje. Poskusimo jih reiti sami. V tej knjigi bodo prikazani samo rezultati reitev brez postopka oziroma programske kode. V kolikor se nam zatakne, lahko preverimo reitev v izvornih datotekah Rmd, ki se nahajajo na repozitoriju. Nekatere naloge od nas zahtevaj, da kaj raziemo sami, z uporabo vgrajene pomoi ali spleta, kot smo to navajeni pri vsakodnevnem programerskem delu. Domaa naloga vsakega sklopa je sestavljena iz nekaj osnovnih nalog, ki ponovijo snov predavanj. Poleg teh pa so tudi teje naloge, pri kateri je potrebno koncepte uporabiti na realni podatkovni mnoici ali samostojno reiti probleme, ki jih na predavanju ne bomo predelali. "],["statini-dashboard.html", "Poglavje 1 Statini dashboard 1.1 Priprava 1.2 Moja prva Shiny aplikacija 1.3 Osnovni sestavni deli 1.4 Formatiranje teksta 1.5 Stranski pano in vnos slik 1.6 Kontrolni Widgeti 1.7 Domaa naloga", " Poglavje 1 Statini dashboard 1.1 Priprava Cilj dananjega predavanja je, da spoznamo knjinico Shiny in strukturo njenih aplikacij. Spoznali bomo osnovne gradnike uporabnikega vmesnika, zaradi esar se bomo zaenkrat omejili le na statine aplikacije. Interaktivne aplikacije bomo spoznali v naslednjem poglavju. Najprej je seveda pomembno, da si namestimo potreben paket Shiny z ukazom install.packages. Odpremo RStudio in v konzolo vpiemo ukaz: install.packages(shiny) Ko je namestitev konana, naloimo paket in z ukazom runExample preverimo, e deluje: library(shiny) runExample(&quot;01_hello&quot;) e vse deluje pravilno, bi se moralo odpreti okno, kot je prikazano na tej sliki: Postavitev elementov je odvisna od velikosti odprtega okna in se lahko nekoliko razlikuje od primera na zgornji sliki. V vsakem primeru lahko z drsnikom spreminjamo tevilo koev, ki v grafu predstavljajo tevilo stolpcev histograma. Na ta nain lahko avtomatsko spreminjamo prikaz histograma. Ko zakljuimo z uporabo aplikacije, s klikom na gumb X v zgornjem desnem kotu aplikacijo zapremo. Na ta nain ustavimo proces v ozadju. Ko se vrnemo v Rstudio, lahko preberemo sporoilo: Listening on http://127.0.0.1:7844. Rstudio je pripravljen na izvedbo novega ukaza. To pomeni, da je aplikacija uspeno zaprta. e Rstudio ni pripravljen na nov ukaz, je aplikacija e vedno odprta nekje v ozadju. Poleg prvega primera 01_hello lahko poenemo tudi druge e pripravljene primere. Tako dobimo obutek, kaj vse nam nudi paket Shiny. runExample(&quot;01_hello&quot;) # histogram runExample(&quot;02_text&quot;) # tabele in data frame-i runExample(&quot;03_reactivity&quot;) # reaktivni izrazi runExample(&quot;04_mpg&quot;) # globalne spremenljivke runExample(&quot;05_sliders&quot;) # drsniki runExample(&quot;06_tabsets&quot;) # zavihki runExample(&quot;07_widgets&quot;) # tekst za pomo in akcijski gumbi runExample(&quot;08_html&quot;) # aplikacija Shiny sestavljena iz HTML runExample(&quot;09_upload&quot;) # primer prenaanja datotek runExample(&quot;10_download&quot;) # primer nalaganja datotek runExample(&quot;11_timer&quot;) # samodejni timer 1.2 Moja prva Shiny aplikacija Novo aplikacijo Shiny lahko ustvarimo s arovnikom. V meniju izberemo File -&gt; New File -&gt; Shiny Web App. Ta proces privzeto ustvari mapo z izbranim imenom in pripravljeno skripto app.R, ki predstavlja zaetni primer. Prvo aplikacijo bomo ustvarili kar sami. Odprimo novo skripto R in vpiimo te ukaze: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Moja prva Shiny aplikacija&quot;) ) server &lt;- function(input, output){} shinyApp(ui = ui, server = server) Dokler skripte R ne shranimo, bo orodna vrstica na vrhu izgledala takole: Ko pa skripto shranimo, se orodna vrstica spremeni v: Kadar Rstudio v zadnji vrstici skripte zazna ukaz shinyApp, samodejno prilagodi orodno vrstico za delo s Shiny R-jem. e opozorilo: e vas R vpraa, v katerem kodiranju elite shraniti skripto, izberite UTF8. Paket Shiny za pravilno delovanje uporablja to kodiranje. Sedaj s klikom na gumb Run App poenimo nao prvo aplikacijo. Prikae se nam okno: eprav ukazov iz zgornje skripte e nismo razloili, smo ustvarili nao prvo in najbolj osnovno aplikacijo Shiny. Aplikacija nam izpie le naslov. V nadaljevanju si bomo podrobneje ogledali, katere gradnike nudi knjinica Shiny. 1.3 Osnovni sestavni deli Naa skripta vsebuje vse potrebne sestavne dele za delovanje aplikacije. Kodo znotraj vsake skripte delimo na 3 glavne sestavne dele: objekt za izdelavo uporabnikega vmesnika imenovan ui, streniko funkcijo server in klic funkcije shinyApp. V uporabnikem vmesniku doloimo razporeditev uporabljenih komponent in obliko nae aplikacije. Znotraj njega definiramo vse komponente spletne strani, kot so besedilo, polja za vnos besedila, polja za izris grafa, itd. Uporabniki vmesnik definiramo s klicem funkcije Shiny, ki sestavi spletno stran v jeziku HTML (v prejnjem primeru je to fluidPage(), ki lahko avtomatsko razporeja elemente dashboard-a). V streniki funkciji pripada vsakemu izhodu (izpis teksta, izris grafa) del kode, ki se izvede ob uporabnikovem dejanju oz. ko pride do spremembe. Streniko funkcijo definiramo tako, da sprejme dva parametra: vhod in izhod. Ko sta ti dve komponenti pripravljeni, lahko kliemo ukaz shinyApp(ui = &lt; moj_vmesnik &gt;, server = &lt; moj_strenik &gt;), ki aplikacijo sestavi in poene. e si predstavljamo uporabniki vmesnik kot komponento, ki nai aplikaciji daje obliko, si lahko streniko funkcijo predstavimo kot komponento, ki nai aplikaciji daje odzivnost. Znotraj nje definiramo vsa pravila in ukaze, ki so potrebni za interaktivno delovanje aplikacije. Delovanje strenike funkcije bomo spoznali v naslednjem predavanju, danes pa se posvetimo uporabnikem vmesniku. 1.4 Formatiranje teksta Preden se nauimo uporabljati bolj zapletene objekte, si oglejmo, kako v aplikacijah Shiny oblikujemo besedilo. Ko poenemo aplikacije, se te prepiejo v jezik HTML. e elimo besedilo naih aplikacij preoblikovati, moramo navodila za preoblikovanje spremeniti v jezik HTML. Shiny R ponuja vrsto funkcij za oblikovanje besedila, ki se ujemajo z oznakami programskega jezika HTML. Nekaj primerov: Funkcija v R oznaka HTML Pomen p() &lt;p&gt; Odstavek teksta. h1() &lt;h1&gt; Naslov prvega nivoja. h2() &lt;h2&gt; Naslov drugega nivoja.    h6() &lt;h6&gt; Naslov estega nivoja. strong() &lt;strong&gt; Krepko oznaeno besedilo. em() &lt;em&gt; Leee oznaeno besedilo. a() &lt;a&gt; Povezava. br() &lt;br&gt; Prekinitev vrstice (prazna vrstica). code() &lt;code&gt; Tekst v obliki kode. R funkcije poleg besedila, ki ga elimo izpisati, sprejmejo tudi parametre, ki definirajo slog, bravo Te definiramo v slogu programskega jezika CSS (Cascading Style Sheet), oziroma tako, da jih podamo v obliki \"&lt;argument1&gt; : &lt;vrednost1&gt;; &lt;argument2&gt; : &lt;vrednost2&gt;; \"..\". Poglejmo si preprost primer: ui &lt;- fluidPage( titlePan&quot;l(&quot;Moja prva Shiny aplikac&quot;ja&quot;), h2(&quot;Lorem ipsum&quot;), #podnaslov #odsek teksta p(&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborem.&quot;), br(), # prekinitev strong(&quot;Kerpko oznaen tekst.&quot;), br(), # prekinitev p(&quot;Odstavek teksta, ki je zeleno obarvan.&quot;, style = &quot;color:green; font-size:8pt&quot;) #CSS stil ) V prvem primeru smo e spoznali funkcijo titlePanel, ki izpie naslov aplikacije. Enak napis bi dobili, e bi funkcijo titlePanel zamenjali s funkcijo h2. Vse elemente, ki jih elimo prikazati na strani (fluidPage), podamo kot parametre tej funkciji. V naem primeru smo najprej dodali dva naslova, nato odstavek s tekstom, ki se avtomatsko prilagaja velikosti strani. Temu sledi e odebeljen tekst in na koncu poljubno formatiran tekst z uporabo CSS. 1.5 Stranski pano in vnos slik e aplikaciji dodamo razline elemente, se bodo ti prikazali vsak v svoji vrstici. Zato paket Shiny vsebuje funkcije, s katerimi lahko razporejamo objekte. V sklopu tega predavanja bomo spoznali le eno razporeditev, na tretjem predavanju pa bomo spoznali e druge razporeditve. Funkcija sidebarLayout razdeli stran na stranski in glavni pano. Funkcija prejme dva vhodna parametra, sidebarPanel in mainPanel, kjer vsak vsebuje svoje komponente (tekst, polja, drsnike, grafe, itd.). Poglejmo si najbolj preprosto uporabo tega gradnika: ui &lt;- fluidPage( titlePanel(&quot;Moja prva Shiny aplikacja&quot;), # Razporediev sidebarLayout sidebarLayout( # Stranski pano sidebarPanel(&quot;Stranski pano&quot;), # Glavni pano mainPanel(&quot;Glavni pano&quot;) ) ) Prikae se nam okno z dvema gradnikoma, ki vsebujeta le tekst. Leva tretjina zaslona je privzeto namenjena stranskemu panoju, desni dve tretjini pa glavnemu panoju. V primeru, da je celotno okno preozko, pa se lahko stranski pano premakne tudi na vrh zaslona. Ve o roni nastavitvi postavitve panojev bomo povedali na tretjem predavanju. V spodnjem primeru nadgradimo zgornji primer tako, da vsak pano vsebuje ve gradnikov in dodamo logotip Data Science: ui &lt;- fluidPage( titlePan&quot;l(&quot;Moja prva Shiny aplikac&quot;ja&quot;), # Razporediev sidebarLayout sidebarLayout( # Stranski pano sidebarPanel( h2(&quot;Stranski pano&quot;), # Naslov &quot;V stranski pano lahko dodamo podamo poljubno tevilo elementov, \\ kot je na primer ta tekst.&quot;, # Tekst ), # Glavni pano mainPanel( h2(&quot;Glavni pano&quot;), # Naslov p(&quot;V glavni pano ravno tako lahko dodamo poljubno tevilo elementov. \\ Dodajmo e logotip Data Science:&quot;), # Tekst br(), # Dodamo malo prostora img(src = &quot;images\\\\DS_FRI_logo.png&quot;, align = &quot;center&quot;), # Slika p(&quot;Pozor: slike morajo biti znotraj mape www!&quot;) ) ) ) Aplikacija ima na levi strani stranski pano, na desni pa glavnega. Za vsako komponento v panojih smo klicali funkcijo, ki izpie panoju kodo HTML za dani objekt. V tem primeru smo aplikaciji dodali tudi sliko. V aplikacijo Shiny lahko vnesemo sliko s funkcijo img(), vendar se mora v mapi z izvorno skripto nahajati mapa www, v kateri je shranjena slika. Vse poti, ki jih podamo funkciji, so relativne glede na to mapo, zato je v prejnjem primeru naa slika v mapi www/images. V mapi www poleg slik lahko hranimo tudi datoteke s pravili za oblikovanje, tekste in druge zunanje elemente, ki jih vnaamo v nao spletno aplikacijo. 1.6 Kontrolni Widgeti Widget-i so pomembni elementi uporabnikega vmesnika, ker nam omogoajo interakcijo z aplikacijo. V tem poglavju na kratko pogledamo kateri so osnovni widget-i paketa Shiny, kako delujejo, pa bomo pokazali na naslednjem predavanju, saj moramo za to prej predstaviti streniko funkcijo. Omenimo le, da jim kot prvi argument podamo identifikacijsko ime (lahko vsebuje le rke, tevilke ali podrtaj), s katerim lahko dostopamo do posameznih vrednosti widget-a. V spodnji tabeli so prikazani widgeti paketa Shiny: funcija opis actionButton Action Button checkboxGroupInput A group of check boxes checkboxInput A single check box dateInput A calendar to aid date selection dateRangeInput A pair of calendars for selecting a date range fileInput A file upload control wizard helpText Help text that can be added to an input form numericInput A field to enter numbers radioButtons A set of radio buttons selectInput A box with choices to select from sliderInput A slider bar submitButton A submit button textInput A field to enter text Poglejmo si, kako definiramo sliderInput, checkboxInput, dateInput in selectInput ter jih dodajmo v na primer: ui &lt;- fluidPage( titlePanel(&quot;Moja prva Shiny aplikacija&quot;), # Razporeditev sidebarLayout sidebarLayout( # Stranski pano sidebarPanel( h2(&quot;Stranski pano&quot;), # Naslov &quot;V stranski pano lahko dodamo podamo poljubno tevilo elementov, \\ kot je na primer ta tekst.&quot;, # Tekst sliderInput( inputId = &quot;drsnik&quot;, # Identifikacijsko ime label = &quot;Izberite vrednost:&quot;, # Besedilo na drsniku min = 0, # Minimalna vrednost max = 100, # Maksimalna vrednost value = 50, # Zaetna vrednost step = 2 # Velikost koraka po drsniku ), checkboxGroupInput( inputId = &quot;checkbox&quot;, # Id. ime label = &quot;Izberite pravilne vrednosti za x, e \\ x &gt; -2 in x &lt; 4:&quot;, # Besedilo na checkboxu choices = c(1, 5, 3.2, 10), # Mone izbire ) ), # Glavni pano mainPanel( h2(&quot;Glavni pano&quot;), # Naslov p(&quot;V glavni pano ravno tako lahko dodamo poljubno tevilo elementov. \\ Dodajmo e logotip Data Science:&quot;), # Tekst br(), # Dodamo malo prostora img(src = &quot;images\\\\DS_FRI_logo.png&quot;, align = &quot;center&quot;), # Slika p(&quot;Pozor: slike morajo biti znotraj mape www!&quot;), dateInput( inputId = &quot;vnos_datuma&quot;, # Id. ime label = &quot;Izberi datum rojstva:&quot;,# Besedilo language = &quot;sl&quot;, # Jezik izpisa datuma min = &quot;1900-1-1&quot;, # Minimalna mona vrednost max = date() # Maksimalna mona vrednost ), selectInput( inputId = &quot;izbire&quot;, # Identifikacijsko ime label = &quot;Izberite monosti:&quot;, # Besedilo na drsniku choices = c(&quot;Plan 1&quot;, # Izbire &quot;Plan 2&quot;, &quot;Plan 3&quot;, &quot;Plan 4&quot;), selected = &quot;Plan 2&quot;, # Privzeta izbira multiple = FALSE # Ve izbir ) ) ) ) Vsi objekti imajo vsaj dva skupna atributa: input_id, ki doloa ime, s katerim dostopamo do vrednosti objekta, in label, ki na objektu izpie tekst z navodili ali pojasnilom. Nato doloimo druge atribute, kot na primer mone izbire, zaetno vrednost, zgornje in spodnje meje vrednosti, ki jih objekt lahko zajame V zgornjem primeru si lahko pomen atributov pogledamo v komentarjih, e pa elimo uporabiti kaken drug widget, si lahko pomagamo z R-jevim ukazom ?, npr. ?selectInput. Tako dostopamo do strani za pomo, ki za vsak gradnik opisujejo uporabo njegovih atributov. V tem primeru se drsnik, polje za izbiro datuma in gumbi za izbiro sicer odzivajo, vendar e niso interaktivni, ker ne vplivajo na ostale gradnike. Za konec si poglejmo e kako izgledajo widget-i aplikacije Shiny, ki jih e nismo obravnavali: 1.7 Domaa naloga Zamislite si, da sestavljate aplikacijo, ki bo beleila nove uporabnike vaih storitev. Vaa naloga je, da sestavite uporabniki vmesnik za dashboard, ki bo beleil: ime, datum rojstva, spol, kraj bivanja, datum zaetka uporabe storitve, storitev, na katero se naroa (monosti A, B, C - ena mona izbira). Poleg teh vnosnih polj naj aplikacija vsebuje e naslov Stranke in gumb, ki bo potrdil shranjevanje podatkov v datoteko. Vsi vhodi naj bodo v levem stolpcu razporeditve sidebar (desnega bomo dopolnili v naslednji domai nalogi). Reitev naj izgleda priblino tako: "],["odzivni-dashboard-i.html", "Poglavje 2 Odzivni dashboard-i 2.1 Uvod 2.2 Priprava 2.3 Strenika funkcija 2.4 Odzivni graf 2.5 Funkcija reactive() 2.6 Domaa naloga", " Poglavje 2 Odzivni dashboard-i 2.1 Uvod V prvem predavanju smo gradili statine aplikacije Shiny. V tem pa bomo pokazali, kako statinim aplikacijam dodamo interaktivnost oziroma, z drugim izrazom, odzivnost na uporabnikove spremembe. Zato bomo danes bolje spoznali streniko funkcijo server. Najprej pa spoznajmo, kaj so vhodi in izhodi aplikacij Shiny. 2.2 Priprava Vhodi in izhodi Aplikacija je odzivna , ko ima objekte, ki sprejmejo uporabnikov ukaz ali vnos podatkov (vhod) in objekte, ki prikaejo rezultate tega ukaza ali vnosa (izhod). Vhode smo delno e obravnavali v prejnjem predavanju, ko smo govorili o widget-ih. Za nekatere widget-e, kot so textInput, dateInput, radioButtons in checkboxInput, je oitno, da sluijo vnosu. Kot smo povedali na prvem predavanju, vsakemu vhodu podamo identifikacijsko ime, ki je lahko sestavljeno le iz rk, tevilk in podrtajev. Pomembno je, da se drimo tega pravila, ker bo aplikacija vrednosti vhoda shranila v element seznama input s tem identifikacijskim imenom. Na podoben nain so definirani tudi izhodi. Obravnavali bomo te tipe izhodov: textOtput: izpie besedilo, plotOutput: prikae graf, tableOutput: izpie tabelo, uiOutput: prikae widget, imageOutput prikae sliko. Spodnji odseku kode prikazuje primer, kako v aplikacijo dodamo izhode: ui &lt;- fluidPage( titlePanel(&quot;Primer izhodov&quot;), plotOutput(&quot;primer_plot&quot;), #primer_plot je identifikacijsko ime textOutput(&quot;primer_tekst&quot;) #primer_tekst je identifikacijsko ime ) server &lt;- function(input, output){} shinyApp(ui = ui, server = server) eprav smo v vmesnik vnesli izhode, ob zagonu aplikacije ti niso vidni, saj so prazni. Izhodi se prikaejo le, ko jim priredimo vrednost ali objekt, za kar potrebujemo streniko funkcijo. 2.3 Strenika funkcija Sedaj, ko smo spoznali vhode in izhode, lahko nadaljujemo s spoznavanjem strenike funkcije. Kot smo e omenili na prvem predavanju, bomo v streniko funkcijo zapisali vse ukaze, ki so potrebni za pravilen izpis v nai aplikaciji. Ko bo aplikacija zaznala spremembo ali drugo dejanje s strani uporabnika, bo ukaze znotraj strenike funkcije ponovno izvrila in posodobila prikaz. 2.3.1 Odzivni tekst Dodajmo prejnjemu primeru streniko funkcijo, ki izpie besedilo: ui &lt;- fluidPage( titlePanel(&quot;Primer izhodov&quot;), plotOutput(&quot;primer_plot&quot;), #primer_plot je identifikacijsko ime textOutput(&quot;primer_tekst&quot;) #primer_tekst je identifikacijsko ime ) server &lt;- function(input, output){ output$primer_tekst &lt;- &quot;Izhodni tekst!&quot; } shinyApp(ui = ui, server = server) Opazimo, da e ne deluje, saj se nam v konzoli prikae napaka: Error : Unexpected character object for output$primer_tekst i Did you forget to use a render function? Napaka nas sprauje, e smo pozabili uporabiti funkcijo render, ki predstavlja odzivno funkcijo. e elimo, da bo aplikacija odzivna, moramo kodo zapisati v odzivnem kontekstu znotraj funkcije renderText(). Nai streniki funkciji dodamo funkcijo renderText(): server &lt;- function(input, output){ output$primer_tekst &lt;- renderText(&quot;Izhodni tekst!&quot;) # odzivni kontekst } Sedaj aplikacija deluje pravilno. Vhod, ki je v tem primeru konstanten, smo podali v odzivni kontekst, funkcija renderText() pa je rezultat tega konteksta predala na izhod. eprav je vrednost izhoda primer_plot prazen, imamo na dashboard-u prostor za izris grafa. Poskusimo sestaviti aplikacijo, ki vsebuje polje za vnos imena in polje, v katerem nam izpie pozdrav glede na vneeno ime. ui &lt;- fluidPage( titlePanel(&quot;Primer odzivne aplikacije.&quot;), sidebarLayout( sidebarPanel( textInput(&quot;ime&quot;, &quot;Vnesite vae ime: &quot;) # vhod ), mainPanel( h3(&quot;Pozdravljen/a, &quot;, textOutput(&quot;izpis&quot;, inline = T) # izhod ), ) ) ) server &lt;- function(input, output) { output$izpis &lt;- renderText(input$ime) } shinyApp(ui = ui, server = server) e poskusimo vnesti besedilo v aplikacijo, opazimo, da se izpis samodejno posodobi takoj po vnosu nove rke, e za vnosom za trenutek poakamo. Ni pa nujno, da le prepiemo vhod na izhod. Vhod lahko poljubno preoblikujemo kar znotraj odzivnega konteksta tako, da v zavitih oklepajih podamo ukaze, ki preoblikujejo vhod v izhod. Oglejmo si posodobljeno streniko funkcijo, ki polepa na izpis. server &lt;- function(input, output){ output$izpis &lt;- renderText({ ime &lt;- input$ime if(nchar(ime) &lt; 2){ #pri praznem polju ali 1 rki izpii navodila. ime &lt;- &quot;prosim vnesi svoje ime.&quot; }else{ if(ime == &quot;datascience&quot;){ ime &lt;- &quot;DataScience@UL-FRI&quot; }else{ ime &lt;- paste(toupper(substr(ime, 1, 1)), #prva rka naj bo velika substr(ime, 2, nchar(ime)), #ostale rke skopiramo &quot;!&quot;, #dodamo e klicaj sep = &quot;&quot;) } } ime }) } Na zgornji sliki nam aplikacija olaja vnos logotipa DataScience@UL-FRI in polepa izpis imen. 2.3.2 Branje datotek in prikaz tabel Sedaj si poglejmo, kako lahko z aplikacijo Shiny preberemo datoteko. Uporabili bomo podatkovno zbirko osebe8.csv, ki vsebuje izmiljene podatke o viini, tei, spolu in imenih oseb. Aplikacija vsebuje polje za vnos poti do datoteke, drsnik, ki doloi maksimalno dolino izpisane tabele, in polje za izpis tabele. ui &lt;- fluidPage(sidebarLayout( sidebarPanel( # Polje za vnos datoteke fileInput( inputId = &quot;dat&quot;, label = &quot;Izberi datoteko:&quot;, buttonLabel = &quot;Brskaj&quot;, ), # Drsnik sliderInput( inputId = &quot;dol&quot;, label = &quot;Maksimalna dolina izpisa:&quot;, min = 1, max = 10, value = 3 ) ), mainPanel(tableOutput(&quot;tabela&quot;)) )) server &lt;- function(input, output) { # Izpis tabele output$tabela &lt;- renderTable({ if (!is.null(input$dat)) { head(read.csv(input$dat$datapath), input$dol) } }) } shinyApp(ui = ui, server = server) Naa aplikacija lahko prikae katerekoli podatke v obliki .csv, ki jih prebermo s funkcijo read.csv. Izpie pa lahko najve 10 vrstic. V zgornji aplikaciji opazimo, da funkcija fileInput prebere le metapodatke datoteke, dejanske podatke pa nato naloimo v streniki funkciji. Metapodatki, ki so na voljo: name: ime datoteke size: velikost datoteke v bajtih type: MIME tip datoteke datapath: pot do zaasnih podatkov 2.4 Odzivni graf Sedaj si oglejmo zahtevneji primer aplikacije, ki vsebuje odzivni graf. Tokrat bo aplikacija samodejno brala podatke, zato morajo biti shranjeni znotraj mape aplikacije. Aplikacija naj prikae graf tee v odvisnosti od viine in naj daje uporabniku monost, da filtrira podatke po spolu in prikae trendno rto. library(shiny) library(ggplot2) # Naloimo in pripravimo podatke df &lt;- read.csv(&quot;osebe8.csv&quot;, stringsAsFactors = T) levels(df$Spol) &lt;- c(&quot;enske&quot;, &quot;Moki&quot;) ui &lt;- fluidPage(titlePanel(&quot;Primer odzivnega grafa:&quot;), sidebarLayout( sidebarPanel( # Filter za spol selectInput( &quot;select_spol&quot;, label = &quot;Izberite spol:&quot;, choices = c(&quot;Vsi&quot;, &quot;Moki&quot;, &quot;enske&quot;), selected = &#39;Vsi&#39;, ), # Opcija za prikaz trendne rte checkboxInput(&quot;trend_l&quot;, label = &quot;Trendna rta&quot;, value = F) ), mainPanel(# Graf plotOutput(&quot;graf&quot;)) )) server &lt;- function(input, output) { # koda za izris grafa output$graf &lt;- renderPlot({ #Apliciramo filter if (input$select_spol != &#39;Vsi&#39;) { df &lt;- df[df$Spol == input$select_spol,] } # Izriemo graf pl &lt;- ggplot(df, aes(x = Visina, y = Teza, color = Spol)) + geom_point() # Grafu dodamo trendno rto, e je tako oznaeno if (input$trend_l) { pl &lt;- pl + geom_smooth( aes(x = Visina, y = Teza), method = &#39;lm&#39;, formula = y ~ x, inherit.aes = F ) } # Vrnemo konni graf pl }) } shinyApp(ui = ui, server = server) V zgorjni kodi vidimo, da potrebujemo dva vhoda, select_spol in trend_l. Z vhodom select_spol iz tabele izberemo le vrstice, ki nas zanimajo, z uporabo trend_l, pa s pomojo linearnega modela na grafu nariemo linearni trend tee v odvisnosti od viine viine. 2.4.1 Odzivni widgeti V prejnjem primeru, kjer smo izpisovali tabelo, smo imeli drsnik, ki je doloal maksimalno tevilo izpisanih vrstic. Mejni vrednosti drsnika sta bili 1 in 10. e elimo zgornjo mejo drsnika nastaviti na tevilo vseh prebranih vrstic v tabeli s podatki, lahko ustvarimo odziven drsnik s pomojo funkcije outputUI(). Tak drsnik se bo posodobil vsaki, ko bomo prebrali datoteko: ui &lt;- fluidPage(sidebarLayout(sidebarPanel( # Polje za vnos datoteke fileInput( inputId = &quot;datoteka&quot;, label = &quot;Izberi datoteko:&quot;, buttonLabel = &quot;Brskaj...&quot;, ), # Odzivni widget uiOutput(&quot;odzivni_drsnik&quot;) ), mainPanel(tableOutput(&quot;tabela&quot;)))) server &lt;- function(input, output) { output$odzivni_drsnik &lt;- renderUI({ if (!is.null(input$datoteka)) { podatki &lt;- read.csv(input$datoteka$datapath) sliderInput( inputId = &quot;drsnik_dolzina&quot;, label = &quot;Dolina izpisa:&quot;, min = 1, max = nrow(podatki), value = min(5, nrow(podatki), na.rm = T), step = 1 ) } }) output$tabela &lt;- renderTable({ if (!is.null(input$datoteka)) { head(read.csv(input$datoteka$datapath), input$drsnik_dolzina) } }) } Podobno, kot smo to naredili za besedilo, tabele in graf, lahko spremenljivki v output-u priredimo drsnik. Ta mora biti definiran znotraj odzivnega konteksta v funkciji renderUI(). V tem primeru dodamo pogoj, da se drsnik prikae samo, e izberemo datoteko. Bodimo pozorni, da je odzivni_drsnik izhod, drsnik_dolzina pa vhodna vrednost za njegov parameter max. Kot vidimo, imajo lahko tudi izhodi svoje vhode. 2.5 Funkcija reactive() Pogosto elimo podatke preoblikovati na nain, ki se ne spreminja, nato pa prikazati na ve razlinih nainov. Recimo, da bi eleli podatkom oseb spremeniti vrednosti v stolpcu spol tako, da bi bil spol zapisan s celo besedo. To bi eleli spremeniti v tabeli in v grafu. Vrednosti vhodov lahko beremo in spreminjamo le v odzivnem kontekstu znotraj funkcij renderPlot in renderTable. V tem primeru bi morali v izraz za izpis vsakega izhoda posebej napisati iste ukaze, ki posodobijo stolpec spol. Temu se izognemo z uporabo funkcije reactive(), ki ustvari odzivni izraz, ki ga lahko ponovno uporabimo. Odzivni izraz si lahko predstavljamo kot pomono funkcijo za obdelavo vhoda-izhoda, ki v aplikaciji ni viden. Njegova vrednost se, tako kot pri ostali vhodih in izhodih, spremeni ob vsaki spremembi. Tu je primer, ki zdruuje prejnje primere: ui &lt;- fluidPage(sidebarLayout( sidebarPanel( fileInput( inputId = &quot;datoteka&quot;, label = &quot;Izberi datoteko:&quot;, buttonLabel = &quot;Brskaj...&quot;, ), # Filter za spol selectInput( &quot;select_spol&quot;, label = &quot;Izberite spol:&quot;, choices = c(&quot;Vsi&quot;, &quot;Moki&quot;, &quot;enske&quot;), selected = &#39;Vsi&#39;, ), # Opcija za prikaz trendne rte checkboxInput(&quot;trend_l&quot;, label = &quot;Trendna rta&quot;, value = F), uiOutput(&quot;odzivni_drsnik&quot;) ), mainPanel(plotOutput(&quot;graf&quot;), tableOutput(&quot;tabela&quot;)) )) server &lt;- function(input, output) { # odzivni izraz osebe &lt;- reactive({ if (!is.null(input$datoteka)) { df &lt;- read.csv(input$datoteka$datapath, stringsAsFactors = T) levels(df$Spol) &lt;- c(&quot;enske&quot;, &quot;Moki&quot;) df } }) output$odzivni_drsnik &lt;- renderUI({ if (!is.null(input$datoteka)) { sliderInput( inputId = &quot;drsnik_dolzina&quot;, label = &quot;Dolina izpisa:&quot;, min = 1, max = nrow(osebe()), value = 5, step = 1 ) } }) output$tabela &lt;- renderTable({ if (!is.null(input$drsnik_dolzina)) { head(osebe(), input$drsnik_dolzina) # kliemo reaktivni izraz } }) # koda za izris grafa output$graf &lt;- renderPlot({ if (!is.null(input$datoteka)) { #Apliciramo filter df &lt;- osebe() if (input$select_spol != &#39;Vsi&#39;) { df &lt;- df[df$Spol == input$select_spol,] } # Izriemo graf pl &lt;- ggplot(df, aes(x = Visina, y = Teza, color = Spol)) + geom_point() # Grafu dodamo trendno rto, e je tako oznaeno if (input$trend_l) { pl &lt;- pl + geom_smooth( aes(x = Visina, y = Teza), method = &#39;lm&#39;, formula = y ~ x, inherit.aes = F ) } # Vrnemo konni graf return(pl) } }) } shinyApp(ui = ui, server = server) Ko uporabljamo odzivne izraze, moramo paziti, da jih kliemo z oklepaji. Tabelo oseb obdelamo le enkrat znotraj odzivnega izraza. Tako lahko pohitrimo posodobitve naih dashboard-ov , predvsem ko imamo ve izhodov, ki zahtevajo podobno obdelavo obsenih podatkov. V naem primeru opazimo tudi, da za izris grafa vrnjene podatke iz funkcije reactive() preprosto filtriramo. 2.6 Domaa naloga Uporabite uporabniki vmesnik, ki ste ga sestavili pri prejnji domai nalogi. V desnem stolpcu, ki smo ga namenoma pustili praznega, prikaite z razpredelnico zadnjih pet prijavljenih strank. Pod tabelo dodajte graf, ki prikazuje tevilo novih strank skozi as. "],["urejanje-oblike-in-razporeditve-dashboard-a.html", "Poglavje 3 Urejanje oblike in razporeditve dashboard-a 3.1 Tip spletnih strani 3.2 Razporeditve in panoji 3.3 Barvne sheme in teme 3.4 Domaa naloga", " Poglavje 3 Urejanje oblike in razporeditve dashboard-a Na prvem predavanju smo spoznali, da obliko aplikacije urejamo v delu kode, ki skrbi za uporabniki vmesnik (ui). Razporeditev gradnikov v nai aplikaciji doloamo na treh nivojih, in sicer: strani (page), razporeditve (layout), panoja (panel). 3.1 Tip spletnih strani Aplikacije so lahko razdeljene na eno ali ve strani. V kodi za uporabniki vmesnik iz prejnjih predavanj opazimo, da ui predstavlja funkcije fluidPage. Funkcija fluidPage pripravi vso potrebno kodo HTML, CSS in JavaScript, ki nam prikae spletno stran v eleni obliki. Poleg funkcije fluidPage lahko uporabimo e funkciji fixedPage in fillPage, ko izdelujemo spletno stran z eno stranjo, ter funkcijo navbarPage za izdelavo aplikacij z ve stranmi. Funkcija fluidPage razporedi objekte enakomerno po celotni irini strani. Funkcija fixedPage deluje podobno kot fluidPage, s to razliko, da vsebuje omejitev irine konne spletne strani, kar skrbi za to, da se naa aplikacija ne razteza prekomerno ez celoten ekran. e uporabimo fillPage, se aplikacija raziri ez celoten ekran oziroma brskalnik. Taka oblika spletne strani je primerna, ko elimo prikazati grafe na celotni spleti strani. Poenite spodnjo kodo in poizkusite spreminjati tip strani med fluidPage, fixedPage in fillPage, ter spremenite height v width. Spreminjajte tudi velikost okna. Kmalu boste opazili razliko vsaj med fillPage in ostalima dvema tipoma strani. ui &lt;- fillPage( #fluid, fixed img(src = &quot;images/DS_FRI_logo.png&quot;, height = &quot;95%&quot;) #width ) server &lt;- function(input, output){} shinyApp(ui = ui, server = server) Funkcija navbarPage daje uporabniku monost, da preko zavihkov dostopa do razlinih strani nae aplikacije. V nadaljevanju bomo veino asa uporabljali fluidPage, ker je najbolj prijazna za uporabo. Ko bomo spoznali razporeditve in panoje, bomo prikazali tudi primer uporabe navbarPage. Spletna stran Shiny s fluidPage je sestavljena iz 12 enako-irokih navideznih stolpcev in poljubno mnogo vrstic. Vsak nov objekt, ki ga dodamo aplikaciji, se avtomatsko vstavi v novo vrstico. Viina vrstice je odvisna od velikosti objekta. V primeru, da bi z vrsticami prekoraili maksimalno viino naega ekrana, se lahko do zadnje vrstice pomaknemo s pomojo mikinega kolesca. eprav ima lahko aplikacije poljubno viino, je pametno, da viino omejimo na viino okna. 3.2 Razporeditve in panoji Ko doloimo tip strani, lahko najprej izberemo razporeditev objektov ali pa se osredotoimo na vstavljanje panojev. Razporeditve objektov doloamo, ko elimo aplikaciji podati tono doloeno strukturo (npr. imamo lahko ve objektov v vsaki vrstici ali pa lahko loimo stran na ve delov). Panoje si lahko predstavljamo kot zabojnike, ki lahko vsebujejo razline objekte, kot so besedilo, grafi, vnosna polja, tabele, druge panoje En primer razporeditve - sidebarLayout - smo e spoznali na prvem predavanju. Sedaj si bomo ogledali ostale glavne vrste razporeditev in panojev. Nato bomo pokazali, kako ustvarimo razporeditev po elji. 3.2.1 Razporeditve Razporeditve, ki jih so na voljo: sidebarLayout: ustvari stranski in glavni pano, splitLayout: ustvari navpine stolpce, verticalLayout: vsak pano postavi v svojo vrstico, flowLayout: panoje razporedi od leve proti desni in od zgoraj navzdol. Razporeditev sidebarLayout smo e spoznali. Sedaj poglejmo e razporeditev splitLayout. ui &lt;- fluidPage( splitLayout( # &lt;- Spremenite e v verticalLayout in flowLayout img(src = &quot;images/DS_FRI_logo.png&quot;), img(src = &quot;images/DS_FRI_logo.png&quot;), img(src = &quot;images/DS_FRI_logo.png&quot;) ) ) server &lt;- function(input, output){} shinyApp(ui = ui, server = server) V tem primeru lahko na vsak logotip gledamo kot na pano zase. Ker uporabljamo splitLayout, je vsaka slika v svojem stolpcu. Ko irino okna zoimo, ostanejo trije stolpci. Razporeditev verticalLayout, logotipe ohrani enega pod drugim, neodvisno od raztezanja okna. V primeru uporabe razporeditve flowLayout pa bodo logotipi razporejeni v eno vrstico. e okno zoamo, se bodo robni logotipi zaeli premikati v spodnjo vrstico. 3.2.2 Veje tevilo hkratnih prikazov Recimo, da elimo za svoje podjetje izdelati aplikacijo za spremljanje poslovanja razlinih oddelkov (npr. oddelek za stike z javnostmi, trenje ali raunovodstvo). Z eno izmed izbranih razporeditev lahko vse informacije prikaemo hkrati. Na spodnji sliki je primer take aplikacije, ki uporablja razporeditev verticalLayout. e elimo videti podatke za raunovodstvo, se moramo pomikati navzdol. ui &lt;- fluidPage(h2(&quot;Moje Podjetje d.o.o.&quot;), verticalLayout( img(src = &quot;images/PR.png&quot;), img(src = &quot;images/marketing.png&quot;), img(src = &quot;images/racunovodstvo.png&quot;) )) Z uporabo razporeditve splitLayout tvegamo, da bi bil prikaz v primeru ozkega ekrana nepregleden. Teava je, da imamo preve informacij, da bi jih lahko smiselno prikazali na eni strani. Hkrati pa so te informacije e logino loene po kategorijah (PR, trenje in raunovodstvo). Bolj smiselno bi bilo, da bi uporabnik izbral le elene informacije. V nadaljevanju si bomo ogledali nekaj nainov, kako to dosei. Pozor: V zgornjem primeru nismo uporabili pravih interaktivnih izhodov, ampak smo uporabili slike namesto grafov, da se koda aplikacije poenostavi in se lahko osredotoimo na razporejanje elementov. 3.2.3 Pano z zavihki Pano tabsetPanel opravlja funkcijo razporeditve in panoja istoasno. Vsebino nam razporedi v podstrani, loene z zavihki. Uporabljamo ga, ko vsaka podstran nae aplikacije zajema nek neodvisen proces, kjer ni potrebe, da so vse informacije prikazane hkrati. Ravno to smo eleli prikazati v prejnjem primeru. Poglejmo si primer: ui &lt;- fillPage( titlePanel(&quot;Moje Podjetje d.o.o.&quot;), tabsetPanel( id = &quot;tabset&quot;, tabPanel( value = &quot;tab1&quot;, &quot;Stiki z javnostjo&quot;, h2(&quot;Kontakti s strani strank&quot;), img(src = &quot;images/PR.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab2&quot;, &quot;Marketing&quot;, h2(&quot;Oglasna kampanja:&quot;), img(src = &quot;images/marketing.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab3&quot;, &quot;Raunovodstvo&quot;, img(src = &quot;images/racunovodstvo.png&quot;, align = &quot;center&quot;) ), ) ) Pano tabsetPanel lahko kombiniramo z ostalimi razporeditvami in paneli. Primer je kombinacija z razporeditvijo sidebarLayout, ki nam omogoa, da levi stranski stolpec namenimo predstavitvi podjetja ali navodilom za uporabo aplikacije, medtem ko so v desnem stolpcu prikazani grafi. ui &lt;- fluidPage(titlePanel(&quot;Moje Podjetje d.o.o.&quot;), sidebarLayout( sidebarPanel( h2(&quot;Opis&quot;), &quot;V zavihkih najdete vizualizacije, ki prikazujejo trenutna \\ stanja za razline oddelke podjetja.&quot; ), mainPanel(tabsetPanel( id = &quot;tabset&quot;, tabPanel( value = &quot;tab1&quot;, &quot;Stiki z javnostjo&quot;, h2(&quot;Kontakti s strani strank&quot;), img(src = &quot;images/PR.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab2&quot;, &quot;Marketing&quot;, h2(&quot;Oglasna kampanja:&quot;), img(src = &quot;images/marketing.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab3&quot;, &quot;Raunovodstvo&quot;, img(src = &quot;images/racunovodstvo.png&quot;, align = &quot;center&quot;) ), )) )) Zgornji primer lahko posodobimo tako, da se opis v stranskem panoju odziva glede na aktivni zavihek. To storimo tako, da dodamo e izhod tekst in posodobimo strenisko funkcijo, kakor je prikazano tu: ui &lt;- fluidPage(titlePanel(&quot;Moje Podjetje d.o.o.&quot;), sidebarLayout( sidebarPanel(h2(&quot;Opis&quot;), p(textOutput(&quot;opis_zavihka&quot;)), ), mainPanel(tabsetPanel( id = &quot;tabset&quot;, tabPanel( value = &quot;tab1&quot;, &quot;Stiki z javnostjo&quot;, h2(&quot;Kontakti s strani strank&quot;), img(src = &quot;images/PR.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab2&quot;, &quot;Marketing&quot;, h2(&quot;Oglasna kampanja:&quot;), img(src = &quot;images/marketing.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab3&quot;, &quot;Raunovodstvo&quot;, img(src = &quot;images/racunovodstvo.png&quot;, align = &quot;center&quot;) ), )))) server &lt;- function(input, output) { output$opis_zavihka &lt;- renderText({ print(names(input$tabset)) if (input$tabset == &quot;tab1&quot;) { return(&quot;Prikaz PR Kampanje.&quot;) } if (input$tabset == &quot;tab2&quot;) { return(&quot;Prikaz oglasne Kampanje.&quot;) } if (input$tabset == &quot;tab3&quot;) { return(&quot;Prikaz raunovodskih podatkov.&quot;) } }) } 3.2.4 Stran z navigacijo e je vsebina, ki jo elimo prikazati v nai aplikaciji, zelo obirna, postanejo zavihki nepregledni. V ta namen lahko uporabimo obliko strani navbarPage. Ta nam vsako podstran uredi pod novim zavihkom in omogoa dodajanje spustnega menija. Nov zavihek ustvarimo z funkcijo tabPanel (prvi parameter vsebuje ime zavihka). Nato definiramo izgled prikaza panoja pod tem zavihkom. S funkcijo navbarMenulahko dodamo spustni meni. Poglejmo si nekoliko obseneji primer: ui &lt;- navbarPage( &quot;Moje Podjetje d.o.o.&quot;, #To je naslov menija/strani #To se bo prikazalo pod prvim zavihkom &quot;Uvod&quot; tabPanel( &quot;Uvod&quot;, h2(&quot;Uvod&quot;), &quot;To je aplikacija za meseno poroilo podjetja &#39;Moje Podjetje&#39;.&quot; ), #To se bo prikazalo pod drugim zavihkom &quot;Trenutno stanje&quot; tabPanel(&quot;Trenutno stanje&quot;, sidebarLayout( sidebarPanel( h2(&quot;Opis&quot;), &quot;V zavihkih najdete vizualizacije, ki prikazujejo trenutna \\ stanja za razline oddelke podjetja.&quot; ), mainPanel( titlePanel(&quot;Oddelki:&quot;), tabsetPanel( id = &quot;tabset&quot;, tabPanel( value = &quot;tab1&quot;, &quot;Stiki z javnostjo&quot;, h2(&quot;Kontakti s strani strank&quot;), img(src = &quot;images/PR.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab2&quot;, &quot;Marketing&quot;, h2(&quot;Oglasna kampanja:&quot;), img(src = &quot;images/marketing.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab3&quot;, &quot;Raunovodstvo&quot;, img(src = &quot;images/racunovodstvo.png&quot;, align = &quot;center&quot;) ), ) ) )), #To se bo prikazalo pod tretjim zavihkom &quot;Zakljuki&quot; tabPanel(&quot;Zakljuki&quot;, &quot;Zakljuki bodo na voljo po seji izvrnega odbora.&quot;), #etrti &quot;zavihek&quot; je spustni meni z dodatnimi izbirami navbarMenu( &quot;Ostalo&quot;, #Dodatna izbira &quot;Kontakti&quot; tabPanel( &quot;Kontakti&quot;, img(src = &quot;images/DS_FRI_logo.png&quot;), br(), p(&quot;mail: datascience@fri.uni-lj.si&quot;) ), #Dodatna izbira &quot;Podpora&quot; tabPanel(&quot;Podpora&quot;, p(&quot;Under construction&quot;)) ) ) Opazimo, da navbarPage ustvari zavihke isto na vrhu strani. Na tak nain preprosto prehajamo med razlinimi deli nae aplikacije. Posamezne strani lahko e vedno ohranijo oblike in razporeditve, ki smo jih videli v prejnjih primerih (primer zavihek Trenutno stanje). Poleg tega lahko zavihkom doloimo ve monosti v obliki spustnega menija, kar vidimo na zavihku Ostalo. 3.2.5 Pano z navigacijo Zadnja vrsta panoja, ki si jo bomo ogledali, je navlistPanel. Pri uporabi navbarPage lahko v primeru, ko imamo ve zavihkov ali pa dalja imena zavihkov, zmanjka prostora v oknu. V takem primeru je bolj pregledno, e imena strani aplikacije prikaemo v obliki kazala. Ravno ta je glavna znailnost navlistPanel razporeditve. Ponovno si to poglejmo na primeru: ui &lt;- fluidPage( titlePanel(&quot;Moje Podjetje d.o.o.&quot;, ), h2(&quot;Meseno poroilo&quot;), navlistPanel( id = &quot;kazalo&quot;, &quot;Uvod&quot;, tabPanel(value = &quot;panel 1.1&quot;, &quot;Izhodno stanje&quot;), tabPanel(value = &quot;panel 1.2&quot;, &quot;Meseni cilji&quot;), &quot;Pregled opravljenega dela&quot;, tabPanel( value = &quot;panel 2.2&quot;, &quot;Trenutno stanje&quot;, tabsetPanel( id = &quot;tabset&quot;, tabPanel( value = &quot;tab1&quot;, &quot;Stiki z javnostjo&quot;, h2(&quot;Kontakti s strani strank&quot;), img(src = &quot;images/PR.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab2&quot;, &quot;Marketing&quot;, h2(&quot;Oglasna kampanja:&quot;), img(src = &quot;images/marketing.png&quot;, align = &quot;center&quot;) ), tabPanel( value = &quot;tab3&quot;, &quot;Raunovodstvo&quot;, img(src = &quot;images/racunovodstvo.png&quot;, align = &quot;center&quot;) ), ) ), tabPanel(value = &quot;panel 2.3&quot;, &quot;Poroila&quot;), &quot;Zakljuki&quot;, tabPanel(value = &quot;panel 1.2&quot;, &quot;Novi meseni cilji&quot;), tabPanel(value = &quot;panel 1.2&quot;, &quot;Nov meseni strateki plan&quot;), ) ) Kot vidimo, se tabPanel z vrednostjo panel 2.2 prikae na desni polovici strani, njegova vsebina pa je v celoti definirana znotraj tabPanel funkcije. Na tak nain bi lahko zelo obirno vsebino razdelili na ve strani. 3.2.6 Rono definirana razporeditev Poleg e pripravljenih razporeditev, ki jih nudi Shiny, lahko sami doloimo razporeditev. Strani aplikacij so razdeljene v vrstice, vsaka z dvanajstimi navideznimi stolpci, na katere lahko postavljamo poljubne objekte in panoje. Za poljubno razporeditev potrebujemo dve funkciji: fluidRow in column. Funkcija fluidRow ustvari novo vrstico, kot njene argumente pa podamo column funkcije. Prvi argument funkcije column predstavlja irino podano v tevilu stolpcev, ez katere se bodo raztezali objekti ali panoji. Definiramo jih s parametri funkcije column?? . Poleg irine lahko s parametrom offset doloimo tudi zamik stolpca. V tem primeru moramo paziti, da ne preseemo dvanajstega stolpca. Vrednost parametra offset se nanaa na zamik od prejnjega definiranega stolpca (column), ne pa od levega roba spletne strani. Ko definiramo strukturo, lahko zanemo vstavljati objekte in panoje. Poglejmo si primer: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Poljubna razporeditev&quot;), fluidRow( column( 6, titlePanel(&quot;Levi stran&quot;), sidebarLayout(sidebarPanel(h3(&quot;Levi stranski pano&quot;)), mainPanel(h3(&quot;Levi glavni pano&quot;))) ), column( 6, titlePanel(&quot;Desna stran&quot;), sidebarLayout(sidebarPanel(h3( &quot;Desni stranski pano&quot; )), mainPanel(h3(&quot;Desni glavni pano&quot;))) ) ), fluidRow(column( 12, titlePanel(&quot;Vrstica, ki se razteza ez vseh 12 stolpcev&quot;), p( &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&quot; ) )), fluidRow( column( 5, titlePanel(&quot;Primer vgnezdenih vrstic&quot;), fluidRow(column(6, wellPanel( &quot;Levi stolpec v novi vrstici&quot; )), column( 6, wellPanel(&quot;Desni stolpec v novi vrstici&quot;) )) # Vgnezdeni stolpci se morajo prav tako seteti v 12 ), column(3, offset = 1, # offset se upoteva od konca prejnjega stolpca fluidRow(h2(br( )), # Prazna vrstica za lepi prikaz column( 12, wellPanel(&quot;Stolpec irine 3, zacne v 6.&quot;) ))), column(3, fluidRow( h2(br()), # Prazna vrstica za lepi prikaz column(6, wellPanel(&quot;Stolpec irine 2.&quot;)), column(6, wellPanel(&quot;Stolpec irine 2.&quot;)) )) ) ) Ob pregledu zgornjega primera opazimo, da lahko znotraj stolpca uporabimo razporeditve in panoje, kot pri navadni obliki strani. Edina razlika je, da je prikaz zoen. Poleg tega lahko znotraj stolpcev gnezdimo nove vrstice. Pri tem moramo paziti, da se irine stolpcev znotraj vgnezdenih vrstic setejejo v 12. Dodan je tudi wellPanel, ki ustvari pano s temnejim ozadnjem in obrobo, da bolje loimo pozicije. 3.3 Barvne sheme in teme Za konec si poglejmo e, kako spreminjamo obliko oziroma barvo samih gradnikov. To naredimo z uporabo paketa bslib. #install.packages(&quot;bslib&quot;) library(bslib) Vse kar moramo storiti, da zamenjamo tematiko okna, je, da tipu okna podamo parameter theme: ui &lt;- fluidPage( theme = bs_theme(&lt;parametri za obliko&gt;), ... Funkciji bs_theme lahko podamo naslednje parametre: version: verzija, ki jo uporabljamo (trenutno privzeta tema 5), bootswatch: izbira prednastavljene teme, bg: barva ozadja, fg: barva ospredja - barva glavnega teksta, primary: barva za povezave, secondary: barva neizstopajoih component, success: barva sporoil o uspehih, info: barva pisave za informiranje, warning: barva za opozorila, danger: barva za napake, base_font: privzeta pisave, code_font: pisava za kodne izseke, heading_font: pisava za naslove, font_scale: faktor poveave pisave. Aplikaciji iz prejnjega primera spremenimo barvo ospredja v svetlo sivo ter ozadje v temno sivo. Barve lahko podajamo s privzetimi besedami ali v obliki RGB. Spremenimo e pisavo naslovov v pisavo Courier: ui &lt;- fluidPage( theme = bs_theme(fg = &quot;lightgray&quot;, bg = &quot;#303030&quot;, heading_font = c(&quot;Courier&quot;)), titlePanel(&quot;Poljubna razporeditev&quot;), ... Poglejmo si e uporabo prednstavljene barvne sheme minty: ui &lt;- fluidPage( theme = bs_theme(bootswatch = &quot;minty&quot;), titlePanel(&quot;Poljubna razporeditev&quot;), ... Vidimo, da je uporaba teh tem sila preprosta. e elimo dobiti imena vseh prednastavljenih tem, uporabimo ukaz bootswatch_themes() bootswatch_themes() ## [1] &quot;cerulean&quot; &quot;cosmo&quot; &quot;cyborg&quot; &quot;darkly&quot; &quot;flatly&quot; &quot;journal&quot; &quot;litera&quot; &quot;lumen&quot; ## [9] &quot;lux&quot; &quot;materia&quot; &quot;minty&quot; &quot;pulse&quot; &quot;sandstone&quot; &quot;simplex&quot; &quot;sketchy&quot; &quot;slate&quot; ## [17] &quot;solar&quot; &quot;spacelab&quot; &quot;superhero&quot; &quot;united&quot; &quot;yeti&quot; 3.4 Domaa naloga Zamislite si, da vas prodajalec koles prosi, da mu sestavite dashboard, s katerim bo nadzoroval prodajo in zaloge v skladiih. Prodajalec ima tri trgovine, vsaka trgovina pa ima svoje skladie. Podatke o prodaji (sales) in o stanju v skladiih (production) najdete v mapi _data/DN3. Ti so agregacije originalnih tabel baze podatkov, ki jih najdete v podmapi bike_stores. Podatke smo pridobili na spletni strani https://www.sqlservertutorial.net/sql-server-sample-database/, na kateri si lahko ogledate njihovo shemo, ki vam bo pomagala razumeti povezave med njimi. Dashboard naj bo sestavljen iz dveh strani: ena bo namenjena produkciji, druga pa prodaji. Stran produkcije naj prikae podatek o koliini, o strokih proizvodnje, o monem prihodku in o morebitnem zasluku koles na zalogi. Hkrati naj dashboard izrie grafa, na katerih prikae 5 najdrajih in 5 najtevilnejih koles na zalogi. Aplikacija mora nuditi monost, da uporabnik podatke filtrira glede na trgovino, kategorijo in znamko koles. Stran prodaje pa bo prikazovala graf prihodkov skozi as. Hkrati naj prikazuje grafe za 3 najbolje zaposlene, trgovine in stranke. Slednje doloimo tako, da izraunamo, kateri zaposleni, trgovina in stranka je ustvarila najveji prihodek. Aplikacija mora uporabniku omogoiti, da izbere asovno obdobje prodaj. Poleg tega mora uporabnik imeti monost, da namesto prihodkov kot metriko uporabi zasluek ali pa koliino koles. Dashboard naj bo torej podoben temu: "],["napredni-nasveti-za-uporabo-paketa-shiny-r.html", "Poglavje 4 Napredni nasveti za uporabo paketa Shiny R 4.1 Odvisnosti widgetov in deklarativno programiranje", " Poglavje 4 Napredni nasveti za uporabo paketa Shiny R V tem poglavju predstavimo nekaj bolj naprednih napotkov za uporabo paketa Shiny. Primeri, ki so tu navedeni, zahtevajo bolj napredno znanje programiranja in razumevanje drugih programskih jezikov, ki niso R. 4.1 Odvisnosti widgetov in deklarativno programiranje Spomnimo se primera odzivnega widgeta v 2. predavanju. e ste bili dovolj pazljivi, ste opazili, da je aplikacija v konzoli vrnila opozorilo: Warning: Error in checkHT: invalid &#39;n&#39; - must contain at least one non-missing element, got none. Zakaj je izpisala opozorilo? Odgovor na vpraanje se nanaa na deklarativno obliko programiranja. Za razliko od klasinega programiranja v R (imperativna oblika), kjer se ukazi izvajajo zaporedno, se pri Shiny aplikacijah ukazi izvajajo le po potrebi in vsi naenkrat. Izhod se bo torej posodobil, ko bo uporabnik spremenil vhod, od katerega je le-ta odvisen. Torej, ob spremembi vhoda se bodo istoasno spremenili vsi izhodi, ki so od njega odvisni. Lahko opazimo, da se vsaki, ko naloimo datoteko, izhodu output$tabela vrednost dodeli dvakrat: prvi, ko se spremeni input$datoteka in se takrat posodobita output$tabela in output$odzivni_drsnik. V tem trenutku ima input$datoteka e neko vrednost, input$drsnik_dolzina pa ima vrednost NULL, zato se pri izvajanjue ukaza prikae opozorilo head(read.csv(input$datoteka$datapath), input$drsnik_dolzina). Drugi se spremeni, ker se je v prejnjem koraku posodobil input$drsnik_dolzina in se output$tabela posodobi glede na njegovo vrednost. V naem primeru se posodabljanje vedno zgodi dvakrat, paziti pa moramo, da ne ustvarimo cikla posodabljana. V tem primeru ga bo Shiny zaznal in nam prekinil delovanje strenika. e se elimo izogniti temu opozorilu moramo spremeniti pogoj, ki nadzoruje prikaz tabele: output$tabela &lt;- renderTable({ #input$datoteka zamejamo z input$drsnik_dolzina if(!is.null(input$drsnik_dolzina)){ ... "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
